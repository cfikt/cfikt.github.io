<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HAProxy 负载均衡</title>
      <link href="/haproxy/haproxy/"/>
      <url>/haproxy/haproxy/</url>
      
        <content type="html"><![CDATA[<p>HAProxy 是一款开源的高性能负载均衡软件，可以将多个服务器组成一个服务器群，在客户端请求到达时，将请求分发到不同的服务器上进行处理，从而提高服务的可用性和性能</p><ul><li><a href="/haproxy/haproxy01/" title="HAProxy 简介与安装">HAProxy 简介与安装</a></li><li><a href="/haproxy/haproxy02/" title="HAProxy 配置">HAProxy 配置</a></li><li><a href="/haproxy/haproxy03/" title="HAProxy 调度算法">HAProxy 调度算法</a></li><li><a href="/haproxy/haproxy04/" title="HAProxy 高级功能">HAProxy 高级功能</a></li><li><a href="/haproxy/haproxy06/" title="HAProxy 实现 HTTPS">HAProxy 实现 HTTPS</a></li></ul><p>​    </p><p>​    </p><p>ACL 是 HAProxy 中的一种条件匹配规则，它可以根据请求中的各种属性（如 IP 地址、URL、HTTP 头部等）来判断请求是否符合特定条件。如果符合条件，则可以将请求转发到指定的服务器组或进行其他操作</p><ul><li><a href="/haproxy/haproxy05/" title="HAProxy ACL">HAProxy ACL</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> HAProxy 负载均衡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> HAProxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 容器编排</title>
      <link href="/k8s/k8s/"/>
      <url>/k8s/k8s/</url>
      
        <content type="html"><![CDATA[<p>对于初学者，Kubernetes 的安装部署都可能是个难点，面对各种报错信息从安装到放弃。Kubernetes 有很多的部署工具进行选择，比如 MiniKube、Kops 等，这里使用原生安装工具 Kubeadm 部署</p><ul><li><a href="/k8s/install01/" title="Kubernetes 部署">Kubernetes 部署</a></li><li><a href="/k8s/install02/" title="Kubernetes 高可用部署">Kubernetes 高可用部署</a></li><li><a href="/k8s/install03/" title="Kubernetes 部署（Controllerd）">Kubernetes 部署（Controllerd）</a></li></ul><p>​    </p><p>​    </p><p>Kubernetes 中 Pod 是一个或多个容器的集合，因此也称之为容器集；是 Kubernetes 中调度、部署和运行应用的最小原子单元</p><ul><li><a href="/k8s/pod/" title="Pod 基本使用">Pod 基本使用</a></li></ul><p>​    </p><p>​    </p><p>在 Kubernetes 中，可以将存储卷视为目录，Pod 中的容器可以挂载和访问该目录，简单来说存储卷就是可供 Pod 中所有容器访问的目录。数据卷在容器内可以像普通目录一样使用，并且能够被多个容器共享。使用数据卷可以实现容器间数据共享，也可以让容器中的数据在容器重启时不会丢失</p><ul><li><a href="/k8s/volumes/" title="存储卷">存储卷</a></li></ul><p>​    </p><p>​    </p><p>持久卷是一种集群级别的存储卷，它独立于 Pod，可以被多个 Pod 使用，与数据卷不同，持久卷通常用于持久化存储数据，以确保在 Pod 重新调度或删除时数据不会丢失</p><ul><li><a href="/k8s/pv/" title="持久卷">持久卷</a></li></ul><p>​    </p><p>​    </p><p>Kubernetes 中的投射卷（projected volume）是一种特殊的卷类型，可以将多个卷投射到一个 Pod 中，Pod 中的容器就可以使用这些数据</p><ul><li><a href="/k8s/%E6%8A%95%E5%B0%84%E5%8D%B7/" title="投射卷">投射卷</a></li></ul><p>​    </p><p>​    </p><p>Kubernetes 中的编排控制器是一种控制器类型，用于管理和协调 Kubernetes 集群中 Pod 对象的部署、扩展、升级和维护</p><ul><li><a href="/k8s/controller/" title="编排控制器">编排控制器</a></li></ul><p>​    </p><p>​    </p><p>在 Kubernetes (K8s) 中，Service 是一种抽象，用于定义一组 Pod 的逻辑网络端点，Service 有一个唯一的 IP 地址和端口，这个 IP 地址和端口将作为该 Service 的访问入口，客户端可以使用这个 IP 地址和端口来访问 Service</p><ul><li><a href="/k8s/service/" title="Service 服务">Service 服务</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes 容器编排 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> 容器云 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHELL 脚本相关问题</title>
      <link href="/ops/shell/"/>
      <url>/ops/shell/</url>
      
        <content type="html"><![CDATA[<p>在初学 SHELL 的时候，经常疑惑 if 或 while 等语句判断条件中的中括号或者双括号有什么不同，特此记录一下</p><p>​    </p><p>SHELL 脚本中 while 循环 [条件] 和 ((条件)) 都可以用来判断循环是否继续执行，但它们有以下不同点：</p><ul><li>while [条件]：中括号表示测试命令，这种写法适用于在循环体中需要使用命令测试条件的情况，例如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i=0</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -lt 10 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    i=$((i+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>while ((条件))：双括号表示算术扩展，这种写法适用于在循环体中需要进行算术运算的情况，例如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i=0</span><br><span class="line"><span class="keyword">while</span> ((i &lt; <span class="number">10</span>))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    ((i++))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 容器技术</title>
      <link href="/docker/docker/"/>
      <url>/docker/docker/</url>
      
        <content type="html"><![CDATA[<p>在学习 Docker 之前，建议提前了解容器技术，便于在学习 Docker 的过程中理解其中的实现原理或者实现过程；在学习了一些相对头疼的概念知识之后，可以更轻松的面对 Docker 容器技术的学习</p><ul><li><a href="/docker/docker01/" title="认识容器">认识容器</a></li><li><a href="/docker/docker02/" title="容器相关技术">容器相关技术</a></li></ul><p>​    </p><p>​    </p><p>在了解了容器相关的概念知识之后，接下来就正式开始进入 Docker 的学习之旅了，不管学习任何服务，第一步，也是最重要的一步，那就是将其部署在自己的环境上，否则一切都是空谈</p><ul><li><a href="/docker/docker03/" title="Docker 简介">Docker 简介</a></li><li><a href="/docker/docker04/" title="Docker 安装">Docker 安装</a></li></ul><p>​    </p><p>​    </p><p>镜像是 Docker 中最重要的三大概念之一，镜像是运行容器的必要条件，使用镜像可以方便、快速的创建并启动容器</p><ul><li><a href="/docker/docker05/" title="Docker 镜像管理">Docker 镜像管理</a></li><li><a href="/docker/docker07/" title="Docker 镜像制作">Docker 镜像制作</a></li></ul><p>​    </p><p>​    </p><p>Dockerfile 是一种可以被 Docker 程序解释执行的脚本文件，由若干条构建镜像所需的指令和说明组成。使用 Dockerfile 可以根据实际业务需要构建符合生产环境的 Docker 镜像，避免手动重复部署镜像的繁琐过程，大大节约了项目部署的时间成本，达到高效的制作 Docker 镜像</p><ul><li><a href="/docker/docker08/" title="Dockerfile 简介">Dockerfile 简介</a></li><li><a href="/docker/docker09/" title="Dockerfile 指令详解">Dockerfile 指令详解</a></li></ul><p>​    </p><p>​    </p><p>容器是镜像运行时的实例，可以将容器看作一个应用程序及其依赖环境打包而成的集装箱，其本质就是将镜像中的程序启动后生成的进程。容器与镜像的关系类似于虚拟机与虚拟机模板</p><ul><li><a href="/docker/docker06/" title="Docker 容器管理">Docker 容器管理</a></li><li><a href="/docker/docker10/" title="Docker 数据管理">Docker 数据管理</a></li></ul><p>​    </p><p>​    </p><p>当成功部署并开始大规模使用 Docker 容器时，网络将会成为 Docker 比较薄弱的部分，因此需要深入了解 Docker 的网络知识，以满足更高的网络需求</p><ul><li><a href="/docker/docker11/" title="Docker 网络模式">Docker 网络模式</a></li><li><a href="/docker/docker12/" title="Docker 网络通信">Docker 网络通信</a></li></ul><p>​    </p><p>​    </p><p>当在一个宿主机内启动较多容器时，如果手动操作会比较繁琐且容器出错，也比较难以控制多个容器之间的启动顺序或者依赖关系，此时推荐使用 Docker 官方的单机编排工具 docker-compose</p><ul><li><a href="/docker/docker13/" title="Docker Compose 简介">Docker Compose 简介</a></li><li><a href="/docker/docker14/" title="Docker Compose 文件详解">Docker Compose 文件详解</a></li></ul><p>​    </p><p>​    </p><p>Docker 仓库是用来存放镜像的地方，又称为镜像仓库，将镜像 Push 到仓库中集中保存，可以更方便的管理和使用 Docker 镜像，在需要镜像的时候，只需要从仓库中 Pull 到本地即可</p><ul><li><a href="/docker/docker15/" title="Harbor 镜像仓库">Harbor 镜像仓库</a></li><li><a href="/docker/docker16/" title="Harbor 高可用">Harbor 高可用</a></li><li><a href="/docker/docker17/" title="Harbor实现HTTPS">Harbor实现HTTPS</a></li></ul><p>​    </p><p>​    </p><p>默认情况下，容器没有资源使用限制，每个容器都可以无限制的使用宿主机的资源，导致资源占用过多。Docker 提供了控制容器使用资源的方法，可以限制容器使用多少内存或多少 CPU 等</p><ul><li><a href="/docker/docker18/" title="Docker 资源限制">Docker 资源限制</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> 容器云 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算 SRE 运维 — 作业集</title>
      <link href="/tasks/task/"/>
      <url>/tasks/task/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="/tasks/task01/" title="云计算 SRE 运维 — 第一周">云计算 SRE 运维 — 第一周</a></li><li><a href="/tasks/task02/" title="云计算 SRE 运维 — 第二周">云计算 SRE 运维 — 第二周</a></li><li><a href="/tasks/task03/" title="云计算 SRE 运维 — 第三周">云计算 SRE 运维 — 第三周</a></li><li><a href="/tasks/task04/" title="云计算 SRE 运维 — 第四周">云计算 SRE 运维 — 第四周</a></li><li><a href="/tasks/task05/" title="云计算 SRE 运维 — 第五周">云计算 SRE 运维 — 第五周</a></li><li><a href="/tasks/task06/" title="云计算 SRE 运维 — 第六周">云计算 SRE 运维 — 第六周</a></li><li><a href="/tasks/task07/" title="云计算 SRE 运维 — 第七周">云计算 SRE 运维 — 第七周</a></li><li><a href="/tasks/task08/" title="云计算 SRE 运维 — 第八周">云计算 SRE 运维 — 第八周</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 云计算 SRE 运维 - 作业集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 误删除文件恢复</title>
      <link href="/linux/linux01/"/>
      <url>/linux/linux01/</url>
      
        <content type="html"><![CDATA[<p>与 Windows 不同的是，在 Linux 中并不存在回收站的概念。使用 <code>rm</code> 之后想要恢复文件，可就不是简简单单的点一下还原就好了。Linux 中误删除文件还原分为两种情况：</p><ol><li>删除以后进程存在删除信息</li><li>删除以后不存在进程信息，只能借助于工具恢复</li></ol><p>​    </p><p>在这里只分析文件被删除后，相关进程还存在信息的情况：一般是有活动进程存在持续标准输入或输出，文件被删除后，进程 PID 依旧存在。这也是有些服务器删除一些文件但是磁盘不释放的原因</p><blockquote><p>当程序运行时，操作系统会专门开辟一块内存区域，提供给当前进程使用，对于依赖的文件，操作系统会发放一个文件描述符，以便读写文件，当执行 rm -f 删除文件时，只是删除了文件的目录索引节点，对于文件系统不可见，但是对于打开它的进程依然可见，即仍然可以使用先前发放的文件描述符读写文件，利用这样的原理，所以可以使用 I/O 重定向的方式来恢复文件</p></blockquote><p>​    </p><p>​    </p><h1 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h1><h2 id="模拟误删除"><a href="#模拟误删除" class="headerlink" title="模拟误删除"></a>模拟误删除</h2><p>创建一个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个文件</span></span><br><span class="line">[root@master01 ~]<span class="comment"># echo &quot;123&quot; &gt; a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line">[root@master01 ~]<span class="comment"># cat a.txt </span></span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>​    </p><p>使用 <code>tail -f</code> 打开该文件，模拟活动进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># tail -f a.txt </span></span><br><span class="line">123</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    </p><p>新开一个终端，删除该文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># rm -rf a.txt</span></span><br></pre></td></tr></table></figure><p>​    </p><h2 id="恢复文件"><a href="#恢复文件" class="headerlink" title="恢复文件"></a>恢复文件</h2><p><code>lsof</code> 查看删除的文件进程是否还存在（如果没有该命令可使用 <code>yum install -y lsof</code> 或者 <code>apt install -y lsof</code> 安装）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># lsof | grep delete | grep a.txt</span></span><br><span class="line"><span class="built_in">tail</span>      1202701       root    3r      REG      253,0     4   33918672 /root/a.txt (deleted)</span><br></pre></td></tr></table></figure><p>​    </p><p>可以看到进程 ID 为 1202701，文件为已删除（deleted） 状态，查看 <code>/proc</code> 路径下该进程的进程操作文件描述符目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@master01 ~]<span class="comment"># ls -al /proc/1202701/fd</span></span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 root root  0 Feb 12 04:47 .</span><br><span class="line">dr-xr-xr-x 9 root root  0 Feb 12 04:47 ..</span><br><span class="line">lrwx------ 1 root root 64 Feb 12 04:47 0 -&gt; /dev/pts/0</span><br><span class="line">lrwx------ 1 root root 64 Feb 12 04:47 1 -&gt; /dev/pts/0</span><br><span class="line">lrwx------ 1 root root 64 Feb 12 04:47 2 -&gt; /dev/pts/0</span><br><span class="line">lr-x------ 1 root root 64 Feb 12 04:47 3 -&gt; <span class="string">&#x27;/root/a.txt (deleted)&#x27;</span></span><br><span class="line">lr-x------ 1 root root 64 Feb 12 04:47 4 -&gt; anon_inode:inotify</span><br></pre></td></tr></table></figure><p>​    </p><p>开始恢复文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝该文件</span></span><br><span class="line">[root@master01 ~]<span class="comment"># cp /proc/1202701/fd/3 a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line">[root@master01 ~]<span class="comment"># cat a.txt </span></span><br><span class="line">123</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 运维 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
